<?xml version="1.0"?>
<!-- ==================================================================== -->
<!-- XMLToolGen configuration file for ObCache SQL 1-table-per-class      -->
<!-- storage schema and stubs                                             -->
<!--                                                                      -->
<!-- Copyright (c) Paul Clark 2008.  All rights reserved.                 -->
<!-- This code comes with NO WARRANTY and is subject to licence agreement -->
<!-- ==================================================================== -->

<xt:tool xmlns:xt="obtools.com/ns/tools">

  <!-- Legal info transferred into header - note xmitoolgen will also
  apply its own copyright and license for portions generated solely by it -->
  <xt:legal>
    // XMI Tool configuration for ObCache SQL Schema
    // Copyright (c) 2008 Paul Clark
    // This code comes with NO WARRANTY and is subject to licence agreement
  </xt:legal>

  <!-- ===== Setup of script processing for rest of file ===== -->
  <xt:script language="C++">
    <!-- Tags to support C++ in XML - $ isn't significant to either -->
    <xt:tags>
      <xt:start-code>$(</xt:start-code>
      <xt:end-code>)$</xt:end-code>
      <xt:start-expr>$=</xt:start-expr>
      <xt:end-expr>=$</xt:end-expr>
    </xt:tags>
  </xt:script>

  <!-- ===== Configuration items for tool ===== -->
  <xt:config file="/etc/obtools/ot-generate-sql-otpc-schema.cfg.xml" 
             root="sql-otpc-schema">
    <xt:map name="typemap" path="typemap/type"/>
  </xt:config>

  <!-- =============== Helper code =================  -->
  <xt:code>
    // Helper to manufacture association links for many-1 associations
    string many_to_one_ref(ObTools::UML::AssociationEnd& a)
    {
      if (!a.is_navigable) return "";

      ObTools::UML::AssociationEnd *other = a.get_other_end();
      ObTools::UML::Association *assoc = a.get_association();

      string type = other->participant->name;

      // Get name - best of: role, association name, referent type
      string name = other->name;  
      if (name.empty()) name = assoc->name;  
      if (name.empty()) name = type;
      name = Text::tolower(name);  // Ensure lc variable

      if (other->multiplicity.upper == 1)
        return "a_"+name+" INTEGER, -- Many to 1 "+type;
      else
	return "";
    }

  </xt:code>

  <!-- =============== Main templates =================  -->
     
  <!-- Table definition -->
  <xt:define name = "Class" scope="class" var="myclass">
    $( string tname = "t_"+Text::tolower(myclass.name); )$
    -- Class $=myclass.name=$ --
    DROP TABLE IF EXISTS $=tname=$;
    CREATE TABLE $=tname=$
    (
      -- Attributes
      <xt:template scope="attribute">
      f_$= a.name =$ $= _config.typemap.get(a.type->name, "???") =$,
      </xt:template>

      -- Associations
      <xt:template scope="association_end">
      $= many_to_one_ref(a) =$
      </xt:template>

      -- Unique ID shared with root and all ancestor/descendant classes
      _id INTEGER PRIMARY KEY
    );
  </xt:define>

  <!-- Template for top-level model -->
  <xt:template name="Model" scope="model">
    <!-- All gets bundled into one file -->
    <xt:file>$= m.name =$.sql</xt:file>
   
    -- SQL Schema for $=m.name=$
    -- Autogenerated by ObCache storage schema generator for SQL 1-table-per-class
    -- ot-generate-sql-otpc-schema

    -- Ultimate object root table
    -- IDs are allocated here and shared by all tables that make up an
    -- individual object
    DROP TABLE IF EXISTS root;
    CREATE TABLE root
    {
      _id BIGINT AUTO_INCREMENT PRIMARY KEY,  -- Unique object ID
      _type BIGINT                            -- Type discriminator
    };

    <!-- Use class template -->
    <xt:use template="Class"/>
  </xt:template>

<!-- === end ===  -->
</xt:tool>  

