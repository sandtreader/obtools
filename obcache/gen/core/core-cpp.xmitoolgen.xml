<?xml version="1.0"?>
<!-- ================================================================ -->
<!-- XMLToolGen configuration file for ObCache core memory classes    -->
<!-- in C++                                                           -->
<!--                                                                  -->
<!-- Copyright (c) 2008 xMill Consulting Limited                      -->
<!-- ================================================================ -->

<xt:tool xmlns:xt="obtools.com/ns/tools">

  <!-- Legal info transferred into header - note xmitoolgen will also
  apply its own copyright and license for portions generated solely by it -->
  <xt:legal>
    // XMI Tool configuration for ObCache memory classes
    // Copyright (c) 2008 xMill Consulting Limited
    // @@@ MASTER SOURCE - PROPRIETARY AND CONFIDENTIAL - NO LICENCE GRANTED
  </xt:legal>

  <!-- ===== Setup of script processing for rest of file ===== -->
  <xt:script language="C++">
    <!-- Tags to support C++ in XML - $ isn't significant to either -->
    <xt:tags>
      <xt:start-code>$(</xt:start-code>
      <xt:end-code>)$</xt:end-code>
      <xt:start-expr>$=</xt:start-expr>
      <xt:end-expr>=$</xt:end-expr>
    </xt:tags>
  </xt:script>

  <!-- ===== Configuration items for tool ===== -->
  <xt:config file="/etc/obtools/ot-generate-memory-cpp.cfg.xml" 
             root="memory-cpp">
    <xt:map name="typemap" path="typemap/type"/>
    <xt:var name="assoctype" path="association/@type" default="vector"/>
  </xt:config>

  <!-- =============== Helper code =================  -->
  <xt:code>
    // Helper to get name of association - either other end's role, or
    // other end's type name
    string assoc_name(UML::AssociationEnd& a)
    {
      UML::AssociationEnd *other = a.get_other_end();

      // Get role or referent type
      string name = other->name;  
      if (name.empty()) name = other->participant->name;
      return Text::tolower(name);  // Ensure lc variable
    }

    // Helper to get type of other end of assocation
    string assoc_type(UML::AssociationEnd& a)
    {
      UML::AssociationEnd *other = a.get_other_end();
      return other->participant->name;
    }

    // Helper to get type of a multiple association
    string assoc_mtype(UML::AssociationEnd& a)
    {
      UML::AssociationEnd *other = a.get_other_end();
      return _config.assoctype+"<"+other->participant->name+" *>";
    }

    // Get C++ type of a given attribute
    string att_type(UML::Attribute& a)
    {
      return _config.typemap.get(a.type->name, "???");
    }

    //Routine to return method signature of operation
    // Set 'call' true for call to method, false (default) for declaration
    string op_sig(ObTools::UML::Operation& op, bool call=false)
    {
      string s;
      if (!call)
      {
        ObTools::UML::Parameter *ret = op.get_return();
        if (ret)
          s = ret->type->name;
        else
          s= "void";
        s += " ";
      }

      s += op.name;
      s += "(";

      int i=0;
      OBTOOLS_UML_FOREACH_PARAMETER(p, op)
        if (i++) s+=", ";
        if (!call)
        {
          s+=p.type->name;
          s+=" ";
        }
        s+=p.name;
      OBTOOLS_UML_ENDFOR

      s+=")";
      return s;
    }
  </xt:code>

  <!-- =============== Main templates =================  -->
     
  <!-- Recursive 'macro' template for packages -->
  <xt:define name="Package" scope="package">

    <xt:dir>$= p.name =$</xt:dir>

    <!-- Recurse to sub-packages -->
    <xt:use template="Package"/>

    <!-- Header file -->
    <xt:template name = "C++ class" scope="class" var="cl">
      <xt:file>$= cl.name =$.h</xt:file>
      // $=p.name=$/$=cl.name=$.h: Header file for $= cl.name =$
      // Autogenerated by ot-generate-memory-cpp
      // DO NOT EDIT!

      #include "ot-obcache.h"
      #include &lt;string>
      #include &lt;list>
      #include &lt;vector>

      <xt:template scope="generalization">
      #include "$= g.gparent->name =$.h"
      </xt:template>

      using namespace std;
      using namespace ObTools;

      // =================================================
      // Forward definitions for classes used in associations
      <xt:template scope="association_end">
	<xt:if cond="a.get_other_end()->is_navigable">
          class $= assoc_type(a) =$;
	</xt:if>
      </xt:template>

      // =================================================
      // Abstract interface for $=cl.name=$
      // This is what is visible externally
      class $= cl.name =$: 
        <xt:template scope="generalization">
          public $= g.gparent->name =$<xt:sep>,</xt:sep>
        </xt:template>
	<xt:if cond="cl.generalizations.empty()">
          public ObCache::Object
        </xt:if>

      {
      public:
	// Get type name, with package 'namespace'
	string get_type_name() { return "$= p.name =$::$= cl.name =$"; }

        <xt:template scope="attribute">
	  <xt:start>// Getter/setter interfaces for attributes
	  </xt:start>
          virtual $= att_type(a) =$ get_$= a.name =$()=0;
	  virtual void set_$= a.name =$($= att_type(a) =$)=0;

        </xt:template>

        <xt:template scope="association_end">
	  <xt:if cond="a.get_other_end()->is_navigable">
	    <xt:if cond="a.get_other_end()->multiplicity.upper==1">
	      <xt:start>// Getter/setter interfaces for 1 associations
	      </xt:start>
              virtual $= assoc_type(a) =$ *get_$= assoc_name(a) =$()=0;
	      virtual void set_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)=0;
	    </xt:if>

	    <xt:if cond="a.get_other_end()->multiplicity.upper==-1">
	      <xt:start>// Getter/setter interfaces for many associations
	      </xt:start>
              virtual $= assoc_mtype(a) =$ get_$= assoc_name(a) =$s()=0;
	      virtual void add_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)=0;
	      virtual void del_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)=0;
	    </xt:if>
	  </xt:if>
        </xt:template>


        <xt:template name= "Method implementation" scope="operation">
          <xt:start>// Interfaces for locally implemented methods
	  </xt:start>
	  virtual $= op_sig(o) =$ =0;
	</xt:template>
      };

      // =================================================
      // In-memory state for $=cl.name=$
      class $= cl.name =$_State: public $= cl.name =$
        <xt:template scope="generalization">
          , public $= g.gparent->name =$_State
        </xt:template>
      {
      private:
        <xt:template scope="attribute">
	  <xt:start>// Attributes
	  </xt:start>
          $= att_type(a) =$ m_$= a.name =$;
        </xt:template>


        <xt:template scope="association_end">
	  <xt:if cond="a.get_other_end()->is_navigable">
	    <xt:if cond="a.get_other_end()->multiplicity.upper==1">
              <xt:start>// 1 associations
	      </xt:start>
	      $= assoc_type(a) =$ *a_$= assoc_name(a) =$;
	    </xt:if>

	    <xt:if cond="a.get_other_end()->multiplicity.upper==-1">
              <xt:start>// Many associations
	      </xt:start>
	      $= assoc_mtype(a) =$ a_$= assoc_name(a) =$s;
	    </xt:if>
	  </xt:if>
        </xt:template>

      public:
        <xt:template scope="attribute">
	  <xt:start>// Real getters/setters for attributes
	  </xt:start>
          $= att_type(a) =$ get_$= a.name =$() 
	  { return m_$= a.name =$; }

	  void set_$= a.name =$($= att_type(a) =$ _v) 
	  { m_$=a.name=$=_v; }

        </xt:template>

        <xt:template scope="association_end">
	  <xt:if cond="a.get_other_end()->is_navigable">
	    <xt:if cond="a.get_other_end()->multiplicity.upper==1">
	      <xt:start>// Real getters/setters for 1 associations
	      </xt:start>
              $= assoc_type(a) =$ *get_$= assoc_name(a) =$() 
	      { return a_$= assoc_name(a) =$; }

	      void set_$= assoc_name(a) =$($= assoc_type(a) =$ *_v) 
	      { a_$=assoc_name(a)=$=_v; }

	    </xt:if>

	    <xt:if cond="a.get_other_end()->multiplicity.upper==-1">
	      <xt:start>// Real getters/setters for many associations
	      </xt:start>
              $= assoc_mtype(a) =$ get_$= assoc_name(a) =$s() 
              { return a_$= assoc_name(a) =$s; }

	      void add_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)
	      { a_$= assoc_name(a) =$s.push_back(_v); }

	      void del_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)
	      { a_$= assoc_name(a) =$s.remove(_v); }

	    </xt:if>
	  </xt:if>
        </xt:template>
      };

      <xt:unless cond="cl.get_operations().empty()">
	// =================================================
	// Manual implementation of $=cl.name=$
	class $= cl.name =$_Impl: public $= cl.name =$_State 
	{
	public:
	  // Locally implemented methods
	  <xt:template name= "Method implementation" scope="operation">
	    $= op_sig(o) =$;
	  </xt:template>
	};
      </xt:unless>

      // =================================================
      // Stub class for $=cl.name=$
      // Used as a lazy-loading placeholder for associations 
      class $= cl.name =$_Stub: public $= cl.name =$,
        <xt:template scope="generalization">
          public $= g.gparent->name =$_Stub<xt:sep>,</xt:sep>
        </xt:template>
	<xt:if cond="cl.generalizations.empty()">
          public ObCache::Stub
        </xt:if>
      {
	// Get object downcasted to $= cl.name =$_Stub
	$= cl.name =$& _ob() throw (ObCache::Exception)
	{
	  $= cl.name =$ *ob = dynamic_cast<$= cl.name =$ *>(real_object());
	  if (!ob) throw(ObCache::Exception("Object is not a $= cl.name =$"));
	  return *ob;
	}

      public:

        <xt:template scope="attribute">
	  <xt:start>// Stub getter/setter interfaces for attributes
	  </xt:start>
          $= att_type(a) =$ get_$= a.name =$()
	  { return _ob().get_$= a.name =$(); }

	  void set_$= a.name =$($= att_type(a) =$ _v)
          { _ob().set_$= a.name =$(_v); }

        </xt:template>

        <xt:template scope="association_end">
	  <xt:if cond="a.get_other_end()->is_navigable">
	    <xt:if cond="a.get_other_end()->multiplicity.upper==1">
	      <xt:start>// Stub getter/setter interfaces for 1 associations
	      </xt:start>
              $= assoc_type(a) =$ *get_$= assoc_name(a) =$()
	      { return _ob().get_$= assoc_name(a) =$(); }
	      void set_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)
	      { return _ob().set_$= assoc_name(a) =$(_v); }
	    </xt:if>

	    <xt:if cond="a.get_other_end()->multiplicity.upper==-1">
	      <xt:start>// Stub getter/setter interfaces for many associations
	      </xt:start>
              $= assoc_mtype(a) =$ get_$= assoc_name(a) =$s()
	      { return _ob().get_$= assoc_name(a) =$s(); }

	      void add_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)
	      { return _ob().add_$= assoc_name(a) =$(_v); }

	      void del_$= assoc_name(a) =$($= assoc_type(a) =$ *_v)
	      { return _ob().del_$= assoc_name(a) =$(_v); }
	    </xt:if>
	  </xt:if>
        </xt:template>


        <xt:template name= "Method implementation" scope="operation">
          <xt:start>// Stub interfaces for locally implemented methods
	  </xt:start>
	  $= op_sig(o) =$
	  { return _ob().$= op_sig(o, true) =$; }
	</xt:template>
      };


    </xt:template>
  </xt:define>

  <!-- Use recursive package macro on top-level model -->
  <xt:use template="Package"/>

<!-- === end ===  -->
</xt:tool>  

